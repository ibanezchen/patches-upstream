From 2762004f923a9ce027319e549dcd7cc9b93ece8a Mon Sep 17 00:00:00 2001
From: Steve Muckle <steve.muckle@linaro.org>
Date: Thu, 15 Oct 2015 16:02:49 -0700
Subject: [PATCH 18/19] sched/cpufreq_sched: check policy before attempting to
 set capacity

A CPU may have an active cpufreq policy with a different governor.
Ensure the governor is cpufreq_sched before proceeding. A quick
check is made prior to grabbing the policy as well to avoid the lock
in the common case.

Signed-off-by: Steve Muckle <steve.muckle@linaro.org>
---
 kernel/sched/cpufreq_sched.c | 18 +++++++++++++++++-
 1 file changed, 17 insertions(+), 1 deletion(-)

diff --git a/kernel/sched/cpufreq_sched.c b/kernel/sched/cpufreq_sched.c
index a8629fd..469d656 100644
--- a/kernel/sched/cpufreq_sched.c
+++ b/kernel/sched/cpufreq_sched.c
@@ -17,8 +17,13 @@
 
 #define THROTTLE_NSEC		50000000 /* 50ms default */
 
+#ifndef CONFIG_CPU_FREQ_DEFAULT_GOV_SCHED
+static struct cpufreq_governor cpufreq_gov_sched;
+#endif
+
 extern unsigned int capacity_margin;
 
+static struct cpumask enabled_cpus;
 static DEFINE_PER_CPU(unsigned long, pcpu_capacity);
 DEFINE_PER_CPU(struct sched_capacity_reqs, cpu_sched_capacity_reqs);
 
@@ -171,6 +176,14 @@ static void cpufreq_sched_set_cap(int cpu, unsigned long capacity)
 	struct gov_data *gd;
 	unsigned long capacity_max = 0;
 
+	/*
+	 * Avoid grabbing the policy if possible. A test is still
+	 * required after locking the CPU's policy to avoid racing
+	 * with the governor changing.
+	 */
+	if (!cpumask_test_cpu(cpu, &enabled_cpus))
+		return;
+
 	/* update per-cpu capacity request */
 	per_cpu(pcpu_capacity, cpu) = capacity;
 
@@ -179,7 +192,8 @@ static void cpufreq_sched_set_cap(int cpu, unsigned long capacity)
 		return;
 	}
 
-	if (!policy->governor_data)
+	if (policy->governor != &cpufreq_gov_sched ||
+	    !policy->governor_data)
 		goto out;
 
 	gd = policy->governor_data;
@@ -298,6 +312,7 @@ static int cpufreq_sched_start(struct cpufreq_policy *policy)
 
 	policy->governor_data = gd;
 	gd->policy = policy;
+	cpumask_or(&enabled_cpus, &enabled_cpus, policy->related_cpus);
 	set_sched_energy_freq();
 	return 0;
 
@@ -310,6 +325,7 @@ static int cpufreq_sched_stop(struct cpufreq_policy *policy)
 {
 	struct gov_data *gd = policy->governor_data;
 
+	cpumask_andnot(&enabled_cpus, &enabled_cpus, policy->related_cpus);
 	clear_sched_energy_freq();
 	if (cpufreq_driver_might_sleep()) {
 		kthread_stop(gd->task);
-- 
1.9.1


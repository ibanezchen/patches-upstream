From aa7b2139bcd3f1bc103033a2a434f07874fb8f28 Mon Sep 17 00:00:00 2001
From: Patrick Bellasi <patrick.bellasi@arm.com>
Date: Mon, 22 Jun 2015 19:49:42 +0100
Subject: [PATCH 19/38] WIP: sched/fair: keep track of energy/capacity
 variations

The current EAS implementation does not allow "to boost" tasks performances,
for example by running them at an higher OPP (or a more capable CPU), even
if that could require a "reasonable" increase in energy consumption.
To defined how much reasonable is an energy increase with respect to a
required boost value, it is required to define and compute a trade-off
between the expected energy and performance variations.
However, the current EAS implementation considers only energy variations
while completely disregard the impact on performance for the selection of
a certain schedule candidate.

This patch extends the eenv energy environment to keep track of both energy
and performance deltas which are implied by the activation of a schedule
candidate.
The performance variation is estimated considering the different capacities
of the CPUs in which the task could be scheduled. The idea is that while
running on a CPU with higher capacity (e.g. higher operating point) the
task could (potentially) complete faster and thus get better performance.

Change-Id: I7c25eaaa17f6e7c9e13659aadc52bbc7ba125cc6
Signed-off-by: Patrick Bellasi <patrick.bellasi@arm.com>
---
 kernel/sched/fair.c | 39 ++++++++++++++++++++++++++++++++++++++-
 1 file changed, 38 insertions(+), 1 deletion(-)

diff --git a/kernel/sched/fair.c b/kernel/sched/fair.c
index 21c7bd3..f878287 100644
--- a/kernel/sched/fair.c
+++ b/kernel/sched/fair.c
@@ -4893,6 +4893,16 @@ struct energy_env {
 	int			src_cpu;
 	int			dst_cpu;
 	int			energy;
+	struct {
+		int before;
+		int after;
+		int diff;
+	} nrg;
+	struct {
+		int before;
+		int after;
+		int delta;
+	} cap;
 };
 
 /*
@@ -5057,6 +5067,22 @@ static unsigned int sched_group_energy(struct energy_env *eenv)
 					eenv->sg_cap = sg;
 
 				cap_idx = find_new_capacity(eenv, sg->sge);
+
+				if (sg->group_weight == 1) {
+					/* Remove capacity of src CPU (before task move) */
+					if (eenv->usage_delta == 0 &&
+						cpumask_test_cpu(eenv->src_cpu, sched_group_cpus(sg))) {
+						eenv->cap.before = sg->sge->cap_states[cap_idx].cap;
+						eenv->cap.delta -= eenv->cap.before;
+					}
+					/* Add capacity of dst CPU  (after task move) */
+					if (eenv->usage_delta != 0 &&
+						cpumask_test_cpu(eenv->dst_cpu, sched_group_cpus(sg))) {
+						eenv->cap.after = sg->sge->cap_states[cap_idx].cap;
+						eenv->cap.delta += eenv->cap.after;
+					}
+				}
+
 				idle_idx = group_idle_state(sg);
 				group_util = group_norm_usage(eenv, sg);
 				sg_busy_energy = (group_util * sg->sge->cap_states[cap_idx].power)
@@ -5100,6 +5126,8 @@ static int energy_diff(struct energy_env *eenv)
 		.usage_delta	= 0,
 		.src_cpu	= eenv->src_cpu,
 		.dst_cpu	= eenv->dst_cpu,
+		.nrg = { 0, 0, 0 },
+		.cap = { 0, 0, 0 },
 	};
 
 	if (eenv->src_cpu == eenv->dst_cpu)
@@ -5117,6 +5145,11 @@ static int energy_diff(struct energy_env *eenv)
 							sched_group_cpus(sg))) {
 			eenv_before.sg_top = eenv->sg_top = sg;
 			energy_before += sched_group_energy(&eenv_before);
+
+			/* Keep track of SRC cpu (before) capacity */
+			eenv->cap.before = eenv_before.cap.before;
+			eenv->cap.delta = eenv_before.cap.delta;
+
 			energy_after += sched_group_energy(eenv);
 
 			/* src_cpu and dst_cpu may belong to the same group */
@@ -5131,7 +5164,11 @@ static int energy_diff(struct energy_env *eenv)
 		}
 	} while (sg = sg->next, sg != sd->groups);
 
-	return energy_after-energy_before;
+	eenv->nrg.before = energy_before;
+	eenv->nrg.after = energy_after;
+	eenv->nrg.diff = eenv->nrg.after - eenv->nrg.before;
+
+	return eenv->nrg.diff;
 }
 
 static int wake_wide(struct task_struct *p)
-- 
1.9.1

